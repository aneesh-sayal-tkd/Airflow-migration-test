name: Branch Protection and Pipeline Trigger
on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
    branches: [tst, prd]
  push:
    branches: [tst, prd]

permissions:
  contents: write
  pull-requests: write
  checks: write
  statuses: write
  security-events: write
  actions: read
  issues: write

jobs:
# ----------------------------------------------------------------------
# 1. Light validation of PR source/target + CODEOWNERS file
# ----------------------------------------------------------------------
  validate-pr:
    name: validate-pr
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Enforce allowed branch flow (dev‚Üítst, tst‚Üíprd)
        run: |
          SRC="${{ github.head_ref }}"
          DST="${{ github.base_ref }}"
          case "${SRC}:${DST}" in
            dev:tst|tst:prd)  echo "‚úÖ branch flow allowed" ;;
            *)                   echo "‚ùå invalid branch flow ${SRC} ‚Üí ${DST}"; exit 1 ;;
          esac
          
      - name: Check that a CODEOWNERS file exists
        run: |
          if [[ -f .github/CODEOWNERS || -f CODEOWNERS || -f docs/CODEOWNERS ]]; then
            echo "‚úÖ CODEOWNERS file found"
          else
            echo "‚ùå No CODEOWNERS file found"; exit 1
          fi
          
      - name: Set job status
        id: set-status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 2. CodeQL and Copilot Autofix Security Analysis
# ----------------------------------------------------------------------
  code-security:
    name: code-security
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: validate-pr
    outputs:
      codeql_status: ${{ steps.set-codeql-status.outputs.status }}
      copilot_status: ${{ steps.set-copilot-status.outputs.status }}
      has_security_issues: ${{ steps.check-security-issues.outputs.has_issues }}
      issues_acknowledged: ${{ steps.check-acknowledgment.outputs.acknowledged }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          queries: security-and-quality
        
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
        
      - name: Perform CodeQL Analysis
        id: codeql-analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python"
          
      - name: Check for CodeQL Security Issues
        id: check-security-issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO="${{ github.repository }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Wait a moment for CodeQL results to be processed
          sleep 10
          
          # Get CodeQL alerts for this repository
          ALERTS=$(gh api "repos/$REPO/code-scanning/alerts" \
            --jq '[.[] | select(.state == "open" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical"))] | length' 2>/dev/null || echo "0")
          
          # Get alerts introduced by this PR
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          NEW_ALERTS=$(gh api "repos/$REPO/code-scanning/alerts" \
            --jq '[.[] | select(.state == "open" and .most_recent_instance.commit_sha == "'$HEAD_SHA'" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical"))] | length' 2>/dev/null || echo "0")
          
          echo "Total open high/critical alerts: $ALERTS"
          echo "New alerts in this PR: $NEW_ALERTS"
          
          if [[ "$NEW_ALERTS" -gt 0 ]]; then
            echo "has_issues=true" >> $GITHUB_OUTPUT
            echo "‚ùå Found $NEW_ALERTS new high/critical security issues in this PR"
            
            # Get detailed alert information
            gh api "repos/$REPO/code-scanning/alerts" \
              --jq '[.[] | select(.state == "open" and .most_recent_instance.commit_sha == "'$HEAD_SHA'" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical")) | {rule: .rule.description, severity: .rule.security_severity_level, location: .most_recent_instance.location, url: .html_url}]' \
              > codeql_issues.json 2>/dev/null || echo "[]" > codeql_issues.json
            
            echo "## üö® CodeQL Security Issues Found" >> $GITHUB_STEP_SUMMARY
            echo "This PR introduces **$NEW_ALERTS** new high/critical security issues:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Format issues for summary
            if [[ -s codeql_issues.json ]]; then
              jq -r '.[] | "- **" + (.severity // "unknown") + "**: " + (.rule // "Unknown Rule") + " in `" + ((.location.path // "Unknown") + ":" + (.location.start_line | tostring)) + "`"' codeql_issues.json >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìù **Copilot Autofix**: Check the Security tab for automated fix suggestions" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No new high/critical security issues found"
          fi
          
      - name: Post Security Issues Comment
        if: steps.check-security-issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let commentBody = `## üö® Security Issues Detected\n\n`;
            commentBody += `This PR introduces new high/critical security issues that must be addressed.\n\n`;
            
            // Read issues if file exists and has content
            let issues = [];
            try {
              if (fs.existsSync('codeql_issues.json')) {
                const content = fs.readFileSync('codeql_issues.json', 'utf8').trim();
                if (content && content !== '[]') {
                  issues = JSON.parse(content);
                }
              }
            } catch (error) {
              console.log('Could not read issues file:', error.message);
            }
            
            if (issues.length > 0) {
              commentBody += `### Issues Found:\n\n`;
              for (let i = 0; i < issues.length; i++) {
                const issue = issues[i];
                commentBody += `**${i + 1}. ${issue.rule || 'Security Issue'}**\n`;
                commentBody += `- **Severity:** ${issue.severity || 'Unknown'}\n`;
                commentBody += `- **Location:** `${issue.location?.path || 'Unknown'}:${issue.location?.start_line || 'Unknown'}`\n`;
                if (issue.url) {
                  commentBody += `- **[View Details](${issue.url})**\n`;
                }
                commentBody += `\n`;
              }
            }
            
            commentBody += `### ü§ñ Copilot Autofix Available\n`;
            commentBody += `GitHub Copilot Autofix has been enabled for this repository. Check the **Security tab** for automated fix suggestions.\n\n`;
            commentBody += `### Next Steps:\n`;
            commentBody += `1. ‚úÖ **Review Copilot Autofix suggestions** in the Security tab\n`;
            commentBody += `2. üîß **Apply fixes** or implement manual fixes\n`;
            commentBody += `3. üîÑ **Push your changes** to trigger a new security scan\n`;
            commentBody += `4. üö´ **Or acknowledge issues** by commenting: \`/acknowledge-security-issues\`\n\n`;
            commentBody += `‚ö†Ô∏è **The workflow is blocked until these issues are resolved or acknowledged.**`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
            
      - name: Check for Issue Acknowledgment
        id: check-acknowledgment
        if: steps.check-security-issues.outputs.has_issues == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          
          # Check for acknowledgment comment
          ACKNOWLEDGED=$(gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
            --jq '.[] | select(.body | contains("/acknowledge-security-issues")) | .user.login' | head -1)
          
          # Check if PR has 'security-issues-acknowledged' label
          LABEL_EXISTS=$(gh api "repos/$REPO/issues/$PR_NUMBER/labels" \
            --jq '.[] | select(.name == "security-issues-acknowledged") | .name' | head -1)
          
          if [[ -n "$ACKNOWLEDGED" || -n "$LABEL_EXISTS" ]]; then
            echo "acknowledged=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Security issues acknowledged by: $ACKNOWLEDGED"
            
            # Add label if not present
            if [[ -z "$LABEL_EXISTS" ]]; then
              gh api "repos/$REPO/issues/$PR_NUMBER/labels" \
                -f labels[]="security-issues-acknowledged" || true
            fi
          else
            echo "acknowledged=false" >> $GITHUB_OUTPUT
            echo "‚ùå Security issues not yet acknowledged"
          fi
          
      - name: Block if Security Issues Not Resolved or Acknowledged
        if: steps.check-security-issues.outputs.has_issues == 'true' && steps.check-acknowledgment.outputs.acknowledged == 'false'
        run: |
          echo "üö´ WORKFLOW BLOCKED: Security issues detected and not acknowledged"
          echo "Please either:"
          echo "  1. Fix the security issues using Copilot Autofix suggestions"
          echo "  2. Push your changes to trigger a new security scan"
          echo "  3. Comment '/acknowledge-security-issues' to proceed with known issues"
          exit 1
          
      - name: Set CodeQL status
        id: set-codeql-status
        if: always()
        run: |
          if [[ "${{ steps.codeql-analysis.outcome }}" == "success" ]]; then
            if [[ "${{ steps.check-security-issues.outputs.has_issues }}" == "true" && "${{ steps.check-acknowledgment.outputs.acknowledged }}" == "false" ]]; then
              echo "status=blocked" >> $GITHUB_OUTPUT
            else
              echo "status=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
          
      - name: Set Copilot status
        id: set-copilot-status
        if: always()
        run: |
          # Copilot Autofix is built-in, so status is based on whether it's enabled and working
          if [[ "${{ steps.check-security-issues.outputs.has_issues }}" == "true" ]]; then
            echo "status=autofix_available" >> $GITHUB_OUTPUT
          else
            echo "status=not_needed" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 3. Code Owner Approval - Always required for all PRs
# ----------------------------------------------------------------------
  codeowner-approval:
    name: codeowner-approval
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' && 
      (needs.code-security.outputs.has_security_issues == 'false' || 
       needs.code-security.outputs.issues_acknowledged == 'true')
    needs: [validate-pr, code-security]
    timeout-minutes: 30
    outputs:
      status: ${{ steps.set-approval-status.outputs.status }}
    steps:
      - name: Wait for a code-owner approval
        id: wait-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          echo "üïô polling every 5 s for code-owner approval (max 30 min)‚Ä¶"
          
          for i in $(seq 1 360); do
            approved=$(gh api "repos/$REPO/pulls/$PR/reviews" \
              --jq '[group_by(.user.login)[].[-1] | select(.state=="APPROVED")] | length')
            if [[ "$approved" -gt 0 ]]; then
              echo "üéâ code-owner has approved ‚Äì check succeeds"
              echo "approved=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "‚åõ timed-out waiting for code-owner approval"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
          
      - name: Set approval status
        id: set-approval-status
        if: always()
        run: |
          if [[ "${{ steps.wait-approval.outputs.approved }}" == "true" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 4. Branch Protection Gate - Enforces required checks for ALL PRs
# ----------------------------------------------------------------------
  branch-protection-gate:
    name: branch-protection-gate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [validate-pr, code-security, codeowner-approval]
    outputs:
      status: ${{ steps.enforce-protection.outputs.status }}
    steps:
      - name: Enforce Branch Protection Requirements
        id: enforce-protection
        run: |
          echo "üîí Enforcing branch protection requirements for ${{ github.base_ref }} branch..."
          
          # Check that all required jobs passed
          VALIDATE_STATUS="${{ needs.validate-pr.outputs.status }}"
          SECURITY_STATUS="${{ needs.code-security.outputs.codeql_status }}"
          CODEOWNER_STATUS="${{ needs.codeowner-approval.outputs.status }}"
          
          echo "üìä Required Check Results:"
          echo "  ‚úÖ validate-pr: $VALIDATE_STATUS"
          echo "  ‚úÖ code-security: $SECURITY_STATUS"
          echo "  ‚úÖ codeowner-approval: $CODEOWNER_STATUS"
          
          # Verify all required checks passed
          FAILED_CHECKS=""
          
          if [[ "$VALIDATE_STATUS" != "success" ]]; then
            echo "‚ùå validate-pr check failed"
            FAILED_CHECKS="${FAILED_CHECKS}validate-pr "
          fi
          
          if [[ "$SECURITY_STATUS" != "success" ]]; then
            echo "‚ùå code-security check failed"  
            FAILED_CHECKS="${FAILED_CHECKS}code-security "
          fi
          
          if [[ "$CODEOWNER_STATUS" != "success" ]]; then
            echo "‚ùå codeowner-approval check failed"
            FAILED_CHECKS="${FAILED_CHECKS}codeowner-approval "
          fi
          
          if [[ -n "$FAILED_CHECKS" ]]; then
            echo "üö´ MERGE BLOCKED: The following required checks failed: $FAILED_CHECKS"
            echo "‚ö†Ô∏è All branch protection requirements must pass before merge is allowed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "üéâ All required branch protection checks passed for ${{ github.base_ref }} branch!"
          echo "‚úÖ PR meets all requirements for merging"
          echo "status=success" >> $GITHUB_OUTPUT

# ----------------------------------------------------------------------
# 5. Platform Approval Gate - ONLY for production (prd) branch
# ----------------------------------------------------------------------
  platform-approval-gate:
    name: platform-approval-gate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.base_ref == 'prd'
    needs: [validate-pr, code-security, codeowner-approval, branch-protection-gate]
    timeout-minutes: 1440  # 24 hours
    outputs:
      status: ${{ steps.platform-approval.outputs.status }}
      approved: ${{ steps.platform-approval.outputs.approved }}
      approver: ${{ steps.platform-approval.outputs.approver }}
    steps:
      - name: Platform Approval Required for Production
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üî¥ PRODUCTION deployment detected"
          echo "üö´ Platform approval is MANDATORY for this PR"
          echo "‚è≥ This job will BLOCK until platform approval is granted"
          
          REPO="${{ github.repository }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Add initial blocking comment to PR
          gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
            -f body="## üî¥ PRODUCTION Deployment - Platform Approval Required

          **Status:** ‚è≥ **BLOCKED** - Waiting for platform team approval  
          **Environment:** üî¥ **PRODUCTION**  
          **Branch:** \`${{ github.head_ref }}\` ‚Üí \`${{ github.base_ref }}\`  

          ### üö´ Merge Status
          This PR **CANNOT be merged** until platform approval is granted.  
          The workflow will remain blocked until approval is received.

          ### ‚è±Ô∏è Approval Process
          - **Timeout:** 24 hours maximum wait time  
          - **Required Action:** Platform team must approve deployment  
          - **Auto-rejection:** Request expires after 24 hours if no response  

          ---
          *Platform approval is mandatory for all production deployments.*"

      - name: Create or Find Platform Approval Issue  
        id: create-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO="${{ github.repository }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Get platform approver usernames from repository variables
          PLATFORM_APPROVER_1="${{ vars.PLATFORM_APPROVER_1 }}"
          PLATFORM_APPROVER_2="${{ vars.PLATFORM_APPROVER_2 }}"
          
          if [[ -z "$PLATFORM_APPROVER_1" || -z "$PLATFORM_APPROVER_2" ]]; then
            echo "‚ùå Platform approver usernames not found in repository variables"
            echo "Please set PLATFORM_APPROVER_1 and PLATFORM_APPROVER_2 in repository variables"
            exit 1
          fi
          
          echo "üë• Authorized platform approvers: $PLATFORM_APPROVER_1, $PLATFORM_APPROVER_2"
          
          # Check if approval issue already exists for this PR
          EXISTING_ISSUE=$(gh api "repos/$REPO/issues" \
            --jq '.[] | select(.title | contains("PRODUCTION Deployment Approval Required - PR #'$PR_NUMBER'") and .state == "open") | .number' | head -1)
          
          if [[ -n "$EXISTING_ISSUE" ]]; then
            echo "üìã Using existing approval issue #$EXISTING_ISSUE"
            ISSUE_NUMBER="$EXISTING_ISSUE"
          else
            # Create new approval issue with professional formatting
            ISSUE_TITLE="üî¥ PRODUCTION Deployment Approval Required - PR #$PR_NUMBER"
            CURRENT_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
            
            ISSUE_BODY=$(cat <<EOF
          # üî¥ Production Deployment Approval Request

          ## üìã Deployment Summary
          | Field | Value |
          |-------|-------|
          | **Environment** | üî¥ **PRODUCTION** |
          | **Migration Type** | \`tst ‚Üí prd\` |
          | **Pull Request** | [#$PR_NUMBER](${{ github.event.pull_request.html_url }}) |
          | **Requested By** | @${{ github.actor }} |
          | **Request Time** | $CURRENT_TIME |
          | **Branch Flow** | \`${{ github.head_ref }}\` ‚Üí \`${{ github.base_ref }}\` |
          | **Workflow Run** | [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |

          ## ‚úÖ Pre-Deployment Validation Status
          All mandatory checks have been completed and passed:
          - ‚úÖ **Branch Flow Validation**: Verified
          - ‚úÖ **Security Analysis**: CodeQL scan completed
          - ‚úÖ **Code Owner Approval**: Approved
          - ‚úÖ **Branch Protection**: All requirements satisfied

          ## üéØ Required Platform Team Action
          Please review this production deployment request and respond with your decision:

          ### ‚úÖ To Approve Production Deployment:
          Comment with any of: \`/approve\`, \`approved\`, \`lgtm\`, \`yes\`

          ### ‚ùå To Reject Production Deployment:  
          Comment with any of: \`/reject\`, \`rejected\`, \`deny\`, \`no\`

          ## üë• Authorized Approvers
          Only the following platform team members can approve this request:
          - @$PLATFORM_APPROVER_1
          - @$PLATFORM_APPROVER_2

          ## ‚è±Ô∏è Approval Timeline & Process
          - **Maximum Wait Time**: 24 hours from request creation
          - **Auto-Rejection**: Request will be automatically rejected if no response within timeout
          - **Approval Requirement**: Only ONE authorized approver needs to respond
          - **Immediate Effect**: Approval/rejection takes effect immediately upon comment

          ## üö® Important Notes
          - This is a **PRODUCTION** environment deployment with potential business impact
          - The associated Pull Request is **BLOCKED** and cannot be merged until approval
          - All security, quality, and code review requirements have been satisfied
          - Platform team approval is the final gate before production deployment

          ## üìû Escalation
          If urgent approval is needed outside business hours, please contact the platform team directly.

          ---
          *This approval request was automatically generated by the CI/CD pipeline.*
          EOF
          )
            
            # Create the approval issue
            ISSUE_RESPONSE=$(gh api "repos/$REPO/issues" \
              -f title="$ISSUE_TITLE" \
              -f body="$ISSUE_BODY" \
              -f assignees[]="$PLATFORM_APPROVER_1" \
              -f assignees[]="$PLATFORM_APPROVER_2" \
              -f labels[]="production-approval" \
              -f labels[]="platform-team" \
              -f labels[]="deployment-gate")
            
            ISSUE_NUMBER=$(echo "$ISSUE_RESPONSE" | jq -r '.number')
            ISSUE_URL=$(echo "$ISSUE_RESPONSE" | jq -r '.html_url')
            
            echo "üìã Created new approval issue #$ISSUE_NUMBER"
            echo "üîó Issue URL: $ISSUE_URL"
          fi
          
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

      - name: Wait for Platform Approval Decision
        id: platform-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚è≥ BLOCKING: Waiting for platform approval decision..."
          echo "üî¥ PRODUCTION deployment cannot proceed without approval"
          
          REPO="${{ github.repository }}"
          ISSUE_NUMBER="${{ steps.create-approval.outputs.issue_number }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PLATFORM_APPROVER_1="${{ vars.PLATFORM_APPROVER_1 }}"
          PLATFORM_APPROVER_2="${{ vars.PLATFORM_APPROVER_2 }}"
          
          echo "üìã Monitoring approval issue: #$ISSUE_NUMBER"  
          echo "üë• Authorized approvers: $PLATFORM_APPROVER_1, $PLATFORM_APPROVER_2"
          echo "‚è∞ Maximum wait time: 24 hours"
          
          TIMEOUT_SECONDS=86400  # 24 hours
          POLL_INTERVAL=30       # Check every 30 seconds  
          MAX_ITERATIONS=$((TIMEOUT_SECONDS / POLL_INTERVAL))
          
          for ((i=1; i<=MAX_ITERATIONS; i++)); do
            CURRENT_TIME=$(date -u "+%H:%M:%S UTC")
            echo "üîç Approval check $i/$MAX_ITERATIONS at $CURRENT_TIME"
            
            # Get all comments on the approval issue
            COMMENTS=$(gh api "repos/$REPO/issues/$ISSUE_NUMBER/comments" --jq '.')
            
            # Process each comment to check for approval/rejection
            while IFS= read -r comment; do
              if [[ -z "$comment" || "$comment" == "null" ]]; then
                continue
              fi
              
              COMMENT_AUTHOR=$(echo "$comment" | jq -r '.user.login')
              COMMENT_BODY=$(echo "$comment" | jq -r '.body' | tr '[:upper:]' '[:lower:]')
              COMMENT_URL=$(echo "$comment" | jq -r '.html_url')
              
              # Check if comment is from authorized platform approver
              if [[ "$COMMENT_AUTHOR" == "$PLATFORM_APPROVER_1" || "$COMMENT_AUTHOR" == "$PLATFORM_APPROVER_2" ]]; then
                echo "üí¨ Decision comment found from authorized approver @$COMMENT_AUTHOR"
                
                # Check for approval keywords
                if [[ "$COMMENT_BODY" =~ (approve|approved|lgtm|yes|/approve) ]]; then
                  APPROVAL_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
                  echo "üéâ ‚úÖ PRODUCTION DEPLOYMENT APPROVED!"
                  echo "üë§ Approved by: @$COMMENT_AUTHOR"  
                  echo "‚è∞ Approval time: $APPROVAL_TIME"
                  echo "üîì PR is now unblocked and ready for merge"
                  
                  # Update PR with approval notification
                  gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
                    -f body="## ‚úÖ Production Deployment Approved

                  ### üìã Approval Summary
                  | Detail | Information |
                  |--------|-------------|
                  | **Status** | ‚úÖ **APPROVED** |
                  | **Approved By** | @$COMMENT_AUTHOR (Platform Team) |
                  | **Approval Time** | $APPROVAL_TIME |
                  | **Environment** | üî¥ Production |
                  | **Decision Link** | [View Approval Comment]($COMMENT_URL) |

                  ### üöÄ Next Steps
                  - ‚úÖ Platform approval requirement satisfied
                  - ‚úÖ PR is now ready for merge  
                  - üöÄ Production deployment will proceed automatically upon merge
                  - üìä Monitor deployment progress in Harness dashboard

                  ---
                  *Production deployment approved by platform team.*"
                  
                  # Set success outputs
                  echo "status=success" >> $GITHUB_OUTPUT
                  echo "approved=true" >> $GITHUB_OUTPUT
                  echo "approver=$COMMENT_AUTHOR" >> $GITHUB_OUTPUT
                  exit 0
                fi
                
                # Check for rejection keywords
                if [[ "$COMMENT_BODY" =~ (reject|rejected|deny|denied|no|/reject) ]]; then
                  REJECTION_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
                  echo "‚ùå PRODUCTION DEPLOYMENT REJECTED"
                  echo "üë§ Rejected by: @$COMMENT_AUTHOR"
                  echo "‚è∞ Rejection time: $REJECTION_TIME" 
                  echo "üö´ PR remains blocked and cannot be merged"
                  
                  # Update PR with rejection notification  
                  gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
                    -f body="## ‚ùå Production Deployment Rejected

                  ### üìã Rejection Summary
                  | Detail | Information |
                  |--------|-------------|
                  | **Status** | ‚ùå **REJECTED** |
                  | **Rejected By** | @$COMMENT_AUTHOR (Platform Team) |
                  | **Rejection Time** | $REJECTION_TIME |
                  | **Environment** | üî¥ Production |
                  | **Decision Link** | [View Rejection Comment]($COMMENT_URL) |

                  ### üö´ Impact
                  - ‚ùå Platform approval **denied**
                  - üö´ PR merge is **blocked** 
                  - ‚ùå Production deployment **cancelled**
                  - üìù Review feedback and address concerns raised

                  ### üìû Next Steps
                  1. Contact the platform team for clarification on rejection reasons
                  2. Address any concerns or issues identified
                  3. Request new platform approval if changes are made
                  4. Ensure all requirements are met before resubmission

                  ---
                  *Production deployment rejected by platform team.*"
                  
                  # Set failure outputs
                  echo "status=failed" >> $GITHUB_OUTPUT
                  echo "approved=false" >> $GITHUB_OUTPUT  
                  echo "rejector=$COMMENT_AUTHOR" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi
            done <<< "$(echo "$COMMENTS" | jq -c '.[]')"
            
            # Show remaining time for approval
            REMAINING_SECONDS=$((TIMEOUT_SECONDS - (i * POLL_INTERVAL)))
            REMAINING_HOURS=$((REMAINING_SECONDS / 3600))  
            REMAINING_MINS=$(( (REMAINING_SECONDS % 3600) / 60 ))
            
            if (( i % 120 == 0 )); then  # Log every hour (120 * 30 seconds)
              echo "‚è±Ô∏è Time remaining: ${REMAINING_HOURS}h ${REMAINING_MINS}m"
            fi
            
            sleep $POLL_INTERVAL
          done
          
          # Timeout reached - no response within 24 hours
          TIMEOUT_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
          echo "‚è∞ TIMEOUT: No platform approval response received within 24 hours"
          echo "üö´ Production deployment request has been automatically rejected"
          echo "‚è∞ Timeout occurred at: $TIMEOUT_TIME"
          
          # Update PR with timeout notification
          gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
            -f body="## ‚è∞ Production Deployment Request Timeout

          ### üìã Timeout Summary  
          | Detail | Information |
          |--------|-------------|
          | **Status** | ‚è∞ **TIMEOUT** |
          | **Timeout Time** | $TIMEOUT_TIME |
          | **Wait Duration** | 24 hours (maximum) |
          | **Environment** | üî¥ Production |
          | **Approval Issue** | #$ISSUE_NUMBER |

          ### üö´ Impact
          - ‚è∞ No response received within 24-hour timeout window
          - üö´ PR merge remains **blocked**
          - ‚ùå Production deployment **cancelled**  
          - üîÑ New approval request required to proceed

          ### üìû Next Steps  
          1. Contact platform team to understand any delays or issues
          2. Request new platform approval for production deployment
          3. Ensure platform team is aware of deployment urgency
          4. Consider escalation if deployment is time-critical

          ---
          *Production deployment request timed out after 24 hours.*"
          
          # Set timeout failure outputs
          echo "status=timeout" >> $GITHUB_OUTPUT
          echo "approved=false" >> $GITHUB_OUTPUT
          echo "timeout=true" >> $GITHUB_OUTPUT
          exit 1

      - name: Close Platform Approval Issue
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO="${{ github.repository }}"
          ISSUE_NUMBER="${{ steps.create-approval.outputs.issue_number }}"
          FINAL_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
          
          # Determine final outcome and create appropriate closing message
          if [[ "${{ steps.platform-approval.outputs.approved }}" == "true" ]]; then
            APPROVER="${{ steps.platform-approval.outputs.approver }}"
            
            FINAL_COMMENT=$(cat <<EOF
          ## ‚úÖ Production Deployment Approved - Request Completed

          ### üìã Final Status Summary
          | Detail | Information |
          |--------|-------------|  
          | **Final Status** | ‚úÖ **APPROVED** |
          | **Approved By** | @$APPROVER (Platform Team) |
          | **Completion Time** | $FINAL_TIME |
          | **Request Duration** | Approved within 24-hour window |
          | **Environment** | üî¥ Production |

          ### üöÄ Deployment Authorization
          - ‚úÖ **Production deployment approved** and authorized for execution
          - ‚úÖ **Pull request unblocked** - merge can now proceed  
          - ‚úÖ **Platform team approval** requirement satisfied
          - üöÄ **Deployment pipeline** will activate automatically upon PR merge

          ### üìä Post-Approval Actions
          - Pull request merge is now enabled
          - Harness deployment pipeline will be triggered automatically
          - Platform team will monitor deployment progress  
          - Production environment will be updated with approved changes

          ### üéØ Business Impact  
          **Approved production deployment will proceed as requested.**  
          Platform team has reviewed and authorized the deployment based on:
          - Completed security and quality validations
          - Successful code review and approvals  
          - Adherence to deployment standards and procedures

          ---
          **‚úÖ Request Status: COMPLETED - APPROVED**  
          *Platform approval process completed successfully.*
          EOF
          )
            
            # Close issue with success status
            gh api "repos/$REPO/issues/$ISSUE_NUMBER" \
              -f state="closed" \
              -f state_reason="completed"
            
            # Add completion labels
            gh api "repos/$REPO/issues/$ISSUE_NUMBER/labels" \
              -f labels[]="production-approved" \
              -f labels[]="deployment-authorized" \
              -f labels[]="completed" || true
              
          else
            # Handle rejection or timeout
            if [[ "${{ steps.platform-approval.outputs.timeout }}" == "true" ]]; then
              REASON="Request timed out after 24 hours with no response from platform team"
              FINAL_STATUS="‚è∞ **TIMEOUT**"
              BUSINESS_IMPACT="**Production deployment cancelled due to timeout.**"
            else
              REJECTOR="${{ steps.platform-approval.outputs.rejector }}"
              REASON="Explicitly rejected by platform team member @$REJECTOR"
              FINAL_STATUS="‚ùå **REJECTED**" 
              BUSINESS_IMPACT="**Production deployment blocked by platform team decision.**"
            fi
            
            FINAL_COMMENT=$(cat <<EOF
          ## ‚ùå Production Deployment Request Completed - Not Approved

          ### üìã Final Status Summary
          | Detail | Information |
          |--------|-------------|
          | **Final Status** | $FINAL_STATUS |
          | **Completion Time** | $FINAL_TIME |
          | **Environment** | üî¥ Production |
          | **Reason** | $REASON |

          ### üö´ Deployment Decision
          - ‚ùå **Production deployment not approved**
          - üö´ **Pull request remains blocked** - merge cannot proceed
          - ‚ùå **Platform approval requirement** not satisfied  
          - üõë **Deployment pipeline** will not be triggered

          ### üìû Next Steps & Recommendations
          1. **Review Decision**: Understand the reason for non-approval
          2. **Address Concerns**: Work with platform team to resolve any issues
          3. **Resubmit Request**: Create new approval request if concerns are addressed
          4. **Escalation Path**: Contact platform team lead if urgent deployment needed

          ### üéØ Business Impact
          $BUSINESS_IMPACT  
          Deployment process has been halted to ensure production environment safety and compliance with organizational deployment policies.

          ### üìã Process Compliance
          Platform approval requirement serves to:
          - Ensure production deployment safety and compliance
          - Validate business readiness for production changes
          - Maintain deployment standards and risk management
          - Provide final review gate for critical environment changes

          ---
          **‚ùå Request Status: COMPLETED - NOT APPROVED**  
          *Platform approval process completed without authorization.*
          EOF
          )
            
            # Close issue with not planned status  
            gh api "repos/$REPO/issues/$ISSUE_NUMBER" \
              -f state="closed" \
              -f state_reason="not_planned"
            
            # Add appropriate completion labels
            if [[ "${{ steps.platform-approval.outputs.timeout }}" == "true" ]]; then
              gh api "repos/$REPO/issues/$ISSUE_NUMBER/labels" \
                -f labels[]="production-timeout" \
                -f labels[]="deployment-blocked" \
                -f labels[]="completed" || true
            else  
              gh api "repos/$REPO/issues/$ISSUE_NUMBER/labels" \
                -f labels[]="production-rejected" \
                -f labels[]="deployment-blocked" \
                -f labels[]="completed" || true
            fi
          fi
          
          # Add the final comment to close the issue
          gh api "repos/$REPO/issues/$ISSUE_NUMBER/comments" -f body="$FINAL_COMMENT"
          
          echo "üìã Platform approval issue #$ISSUE_NUMBER has been closed"

      - name: Block Merge if Platform Approval Not Granted
        if: steps.platform-approval.outputs.approved != 'true'
        run: |
          echo "üö´ MERGE BLOCKED: Production deployment requires platform approval"
          
          if [[ "${{ steps.platform-approval.outputs.timeout }}" == "true" ]]; then
            echo "‚è∞ REASON: Platform approval request timed out after 24 hours"
            echo "üìù ACTION NEEDED: Contact platform team and request new approval"
          else
            REJECTOR="${{ steps.platform-approval.outputs.rejector }}"
            echo "‚ùå REASON: Production deployment explicitly rejected by @$REJECTOR"  
            echo "üìù ACTION NEEDED: Address platform team concerns and request new approval"
          fi
          
          echo ""
          echo "üî¥ PRODUCTION DEPLOYMENT CANNOT PROCEED"
          echo "üö´ This PR cannot be merged without platform team approval"
          echo "üìû Contact the platform team for assistance with approval process"
          
          exit 1

# ----------------------------------------------------------------------
# 6. Deployment Pipeline - Runs after successful merge to target branches
# ----------------------------------------------------------------------
  trigger-harness-pipeline:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/tst' || github.ref == 'refs/heads/prd')
    outputs:
      harness_status: ${{ steps.set-harness-status.outputs.status }}
    steps:
       - name: Checkout code
         uses: actions/checkout@v4
         
       - name: Check Previous PR Workflow Status
         id: check-pr-status
         env:
           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
         run: |
           echo "üîç Checking status of previous PR workflow..."
           
           # Get the merge commit PR number
           COMMIT_MSG=$(git log -1 --pretty=%B | head -1)
           if [[ "$COMMIT_MSG" =~ Merge\ pull\ request\ #([0-9]+) ]]; then
             PR_NUMBER="${BASH_REMATCH[1]}"
             echo "üîó Found PR: #$PR_NUMBER"
           else
             echo "‚ùå Could not extract PR number from merge commit: $COMMIT_MSG"
             exit 1
           fi
           
           REPO="${{ github.repository }}"
           
           # Get PR information
           PR_INFO=$(gh api "repos/$REPO/pulls/$PR_NUMBER")
           HEAD_SHA=$(echo "$PR_INFO" | jq -r '.head.sha')
           
           # Find matching workflow run
           MATCHING_RUNS=$(gh api "repos/$REPO/actions/runs" --paginate \
             --jq '.workflow_runs[] | select(.head_sha == "'$HEAD_SHA'" and .name == "Branch Protection and Pipeline Trigger" and .event == "pull_request")')
           
           if [[ -z "$MATCHING_RUNS" ]]; then
             echo "‚ùå No workflow run found for head SHA: $HEAD_SHA"
             exit 1
           fi
           
           # Get the latest matching run
           LATEST_RUN=$(echo "$MATCHING_RUNS" | jq -s 'sort_by(.run_number) | reverse | .[0]')
           WORKFLOW_ID=$(echo "$LATEST_RUN" | jq -r '.id')
           WORKFLOW_CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
           
           if [[ "$WORKFLOW_CONCLUSION" != "success" ]]; then
             echo "‚ùå PR workflow was not successful: $WORKFLOW_CONCLUSION"
             exit 1
           fi
           
           # Get job statuses
           JOBS=$(gh api "repos/$REPO/actions/runs/$WORKFLOW_ID/jobs" --jq '.jobs')
           
           VALIDATE_PR_STATUS=$(echo "$JOBS" | jq -r '.[] | select(.name == "validate-pr") | .conclusion')
           CODE_SECURITY_STATUS=$(echo "$JOBS" | jq -r '.[] | select(.name == "code-security") | .conclusion')
           CODEOWNER_APPROVAL_STATUS=$(echo "$JOBS" | jq -r '.[] | select(.name == "codeowner-approval") | .conclusion')
           BRANCH_PROTECTION_STATUS=$(echo "$JOBS" | jq -r '.[] | select(.name == "branch-protection-gate") | .conclusion')
           
           echo "‚úÖ validate-pr: $VALIDATE_PR_STATUS"
           echo "‚úÖ code-security: $CODE_SECURITY_STATUS"
           echo "‚úÖ codeowner-approval: $CODEOWNER_APPROVAL_STATUS"
           echo "‚úÖ branch-protection-gate: $BRANCH_PROTECTION_STATUS"
           
           # For production deployments, also check platform approval
           PLATFORM_APPROVAL_STATUS="not_required"
           if [[ "${{ github.ref_name }}" == "prd" ]]; then
             PLATFORM_APPROVAL_STATUS=$(echo "$JOBS" | jq -r '.[] | select(.name == "platform-approval-gate") | .conclusion')
             echo "‚úÖ platform-approval-gate: $PLATFORM_APPROVAL_STATUS"
             
             if [[ "$PLATFORM_APPROVAL_STATUS" != "success" ]]; then
               echo "‚ùå Platform approval gate failed for production deployment"
               exit 1
             fi
           fi
           
           # Verify all checks passed
           if [[ "$VALIDATE_PR_STATUS" == "success" && "$CODE_SECURITY_STATUS" == "success" && "$CODEOWNER_APPROVAL_STATUS" == "success" && "$BRANCH_PROTECTION_STATUS" == "success" ]]; then
             echo "üéâ All required checks passed! Proceeding with deployment"
           else
             echo "‚ùå Not all required checks passed"
             exit 1
           fi
           
           echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
           echo "validate_pr_status=$VALIDATE_PR_STATUS" >> $GITHUB_OUTPUT
           echo "code_security_status=$CODE_SECURITY_STATUS" >> $GITHUB_OUTPUT
           echo "codeowner_approval_status=$CODEOWNER_APPROVAL_STATUS" >> $GITHUB_OUTPUT
           echo "branch_protection_status=$BRANCH_PROTECTION_STATUS" >> $GITHUB_OUTPUT
           echo "platform_approval_status=$PLATFORM_APPROVAL_STATUS" >> $GITHUB_OUTPUT
           echo "workflow_run_id=$WORKFLOW_ID" >> $GITHUB_OUTPUT

       - name: Determine migration configuration
         id: migration-config
         run: |
           BRANCH_NAME="${{ github.ref_name }}"
         
           if [[ "$BRANCH_NAME" == "tst" ]]; then
             echo "migration_type=dev-to-tst" >> $GITHUB_OUTPUT
             echo "environment=tst" >> $GITHUB_OUTPUT
             echo "requires_platform_approval=false" >> $GITHUB_OUTPUT
           elif [[ "$BRANCH_NAME" == "prd" ]]; then
             echo "migration_type=tst-to-prd" >> $GITHUB_OUTPUT
             echo "environment=prd" >> $GITHUB_OUTPUT
             echo "requires_platform_approval=true" >> $GITHUB_OUTPUT
           fi
          
           echo "üéØ Target branch: $BRANCH_NAME"
           echo "üì¶ Migration type: $(cat $GITHUB_OUTPUT | grep migration_type | cut -d'=' -f2)"
           echo "üîê Platform approval required: $(cat $GITHUB_OUTPUT | grep requires_platform_approval | cut -d'=' -f2)"

       - name: Get commit details
         id: commit-info
         run: |
           echo "commit_message=$(git log -1 --pretty=%B | head -1)" >> $GITHUB_OUTPUT
           echo "commit_author=$(git log -1 --pretty=%an)" >> $GITHUB_OUTPUT
           echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT

       - name: Get PR details from merge commit
         id: pr-info
         run: |
           PR_NUMBER="${{ steps.check-pr-status.outputs.pr_number }}"
           echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
           echo "pr_url=https://github.com/${{ github.repository }}/pull/$PR_NUMBER" >> $GITHUB_OUTPUT
           echo "üîó Using PR: #$PR_NUMBER"

       - name: Trigger Harness Pipeline
         id: trigger-pipeline
         run: |
           echo "üöÄ Triggering Harness pipeline for ${{ steps.migration-config.outputs.migration_type }}"
           
           # Set platform approval information based on environment
           if [[ "${{ steps.migration-config.outputs.requires_platform_approval }}" == "true" ]]; then
             PLATFORM_APPROVAL_STATUS="required_and_approved"
             echo "‚úÖ Production deployment - Platform approval was required and granted"
           else
             PLATFORM_APPROVAL_STATUS="not_required" 
             echo "‚ÑπÔ∏è Test deployment - Platform approval not required"
           fi
          
           JOB_STATUSES=$(cat <<EOF
           {
             "validate_pr": "${{ steps.check-pr-status.outputs.validate_pr_status }}",
             "code_security": {
               "codeql": "${{ steps.check-pr-status.outputs.code_security_status }}",
               "copilot_autofix": "completed_in_pr",
               "had_security_issues": "checked_in_pr",
               "issues_acknowledged": "resolved_in_pr"
             },
             "codeowner_approval": "${{ steps.check-pr-status.outputs.codeowner_approval_status }}",
             "branch_protection_gate": "${{ steps.check-pr-status.outputs.branch_protection_status }}",
             "platform_approval": {
               "status": "$PLATFORM_APPROVAL_STATUS",
               "required": "${{ steps.migration-config.outputs.requires_platform_approval }}",
               "gate_status": "${{ steps.check-pr-status.outputs.platform_approval_status }}"
             },
             "workflow_run_id": "${{ github.run_id }}",
             "pr_number": "${{ steps.check-pr-status.outputs.pr_number }}",
             "pr_workflow_run_id": "${{ steps.check-pr-status.outputs.workflow_run_id }}"
           }
           EOF
           )
          
           RESPONSE=$(curl -s -w "%{http_code}" -X POST "${{ secrets.HARNESS_WEBHOOK_URL }}" \
             -H "Content-Type: application/json" \
             -d "{
               \"repository\": \"${{ github.server_url }}/${{ github.repository }}\",
               \"triggered_by\": \"${{ github.actor }}\",
               \"migration_type\": \"${{ steps.migration-config.outputs.migration_type }}\",
               \"environment\": \"${{ steps.migration-config.outputs.environment }}\",
               \"PR_URL\": \"${{ steps.pr-info.outputs.pr_url }}\",
               \"EDB_ID\": \"${{ vars.EDB_ID }}\",
               \"job_statuses\": $JOB_STATUSES,
               \"commit_sha\": \"${{ github.sha }}\",
               \"commit_author\": \"${{ steps.commit-info.outputs.commit_author }}\",
               \"branch_name\": \"${{ github.ref_name }}\",
               \"requires_platform_approval\": \"${{ steps.migration-config.outputs.requires_platform_approval }}\"
             }")
          
           HTTP_CODE="${RESPONSE: -3}"
           RESPONSE_BODY="${RESPONSE%???}"
         
           if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
             echo "‚úÖ Successfully triggered Harness pipeline"
             echo "triggered=true" >> $GITHUB_OUTPUT
             echo "üîó Related PR: ${{ steps.pr-info.outputs.pr_url }}"
             if [[ "${{ steps.migration-config.outputs.requires_platform_approval }}" == "true" ]]; then
               echo "üë§ Production deployment - Platform approved"
             fi
           else
             echo "‚ùå Failed to trigger Harness pipeline (HTTP $HTTP_CODE)"
             echo "triggered=false" >> $GITHUB_OUTPUT
             echo "Response: $RESPONSE_BODY"
             exit 1
           fi

       - name: Set Harness status
         id: set-harness-status
         if: always()
         run: |
           if [[ "${{ steps.trigger-pipeline.outputs.triggered }}" == "true" ]]; then
             echo "status=success" >> $GITHUB_OUTPUT
           else
             echo "status=failure" >> $GITHUB_OUTPUT
           fi
