name: Branch Protection and Pipeline Trigger
on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
    branches: [tst, prd]
  push:
    branches: [tst, prd]

permissions:
  contents: write
  pull-requests: write
  checks: write
  statuses: write
  security-events: write
  actions: read
  issues: write

jobs:
# ----------------------------------------------------------------------
# 1. Light validation of PR source/target + CODEOWNERS file
# ----------------------------------------------------------------------
  validate-pr:
    name: validate-pr
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    outputs:
      status: ${{ steps.set-status.outputs.status }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Enforce allowed branch flow (dev‚Üítst, tst‚Üíprd)
        run: |
          SRC="${{ github.head_ref }}"
          DST="${{ github.base_ref }}"
          case "${SRC}:${DST}" in
            dev:tst|tst:prd)  echo "‚úÖ branch flow allowed" ;;
            *)                   echo "‚ùå invalid branch flow ${SRC} ‚Üí ${DST}"; exit 1 ;;
          esac
          
      - name: Check that a CODEOWNERS file exists
        run: |
          if [[ -f .github/CODEOWNERS || -f CODEOWNERS || -f docs/CODEOWNERS ]]; then
            echo "‚úÖ CODEOWNERS file found"
          else
            echo "‚ùå No CODEOWNERS file found"; exit 1
          fi
          
      - name: Set job status
        id: set-status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 2. CodeQL and Copilot Autofix Security Analysis
# ----------------------------------------------------------------------
  code-security:
    name: code-security
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: validate-pr
    outputs:
      codeql_status: ${{ steps.set-codeql-status.outputs.status }}
      copilot_status: ${{ steps.set-copilot-status.outputs.status }}
      has_security_issues: ${{ steps.check-security-issues.outputs.has_issues }}
      issues_acknowledged: ${{ steps.check-acknowledgment.outputs.acknowledged }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          queries: security-and-quality
        
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
        
      - name: Perform CodeQL Analysis
        id: codeql-analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python"
          
      - name: Check for CodeQL Security Issues
        id: check-security-issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO="${{ github.repository }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Wait a moment for CodeQL results to be processed
          sleep 10
          
          # Get CodeQL alerts for this repository
          ALERTS=$(gh api "repos/$REPO/code-scanning/alerts" \
            --jq '[.[] | select(.state == "open" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical"))] | length' 2>/dev/null || echo "0")
          
          # Get alerts introduced by this PR
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          NEW_ALERTS=$(gh api "repos/$REPO/code-scanning/alerts" \
            --jq '[.[] | select(.state == "open" and .most_recent_instance.commit_sha == "'$HEAD_SHA'" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical"))] | length' 2>/dev/null || echo "0")
          
          echo "Total open high/critical alerts: $ALERTS"
          echo "New alerts in this PR: $NEW_ALERTS"
          
          if [[ "$NEW_ALERTS" -gt 0 ]]; then
            echo "has_issues=true" >> $GITHUB_OUTPUT
            echo "‚ùå Found $NEW_ALERTS new high/critical security issues in this PR"
            
            # Get detailed alert information
            gh api "repos/$REPO/code-scanning/alerts" \
              --jq '[.[] | select(.state == "open" and .most_recent_instance.commit_sha == "'$HEAD_SHA'" and (.rule.security_severity_level == "high" or .rule.security_severity_level == "critical")) | {rule: .rule.description, severity: .rule.security_severity_level, location: .most_recent_instance.location, url: .html_url}]' \
              > codeql_issues.json 2>/dev/null || echo "[]" > codeql_issues.json
            
            echo "## üö® CodeQL Security Issues Found" >> $GITHUB_STEP_SUMMARY
            echo "This PR introduces **$NEW_ALERTS** new high/critical security issues:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Format issues for summary
            if [[ -s codeql_issues.json ]]; then
              jq -r '.[] | "- **" + (.severity // "unknown") + "**: " + (.rule // "Unknown Rule") + " in `" + ((.location.path // "Unknown") + ":" + (.location.start_line | tostring)) + "`"' codeql_issues.json >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üìù **Copilot Autofix**: Check the Security tab for automated fix suggestions" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No new high/critical security issues found"
          fi
          
      - name: Post Security Issues Comment
        if: steps.check-security-issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let commentBody = `## üö® Security Issues Detected\n\n`;
            commentBody += `This PR introduces new high/critical security issues that must be addressed.\n\n`;
            
            // Read issues if file exists and has content
            let issues = [];
            try {
              if (fs.existsSync('codeql_issues.json')) {
                const content = fs.readFileSync('codeql_issues.json', 'utf8').trim();
                if (content && content !== '[]') {
                  issues = JSON.parse(content);
                }
              }
            } catch (error) {
              console.log('Could not read issues file:', error.message);
            }
            
            if (issues.length > 0) {
              commentBody += `### Issues Found:\n\n`;
              for (let i = 0; i < issues.length; i++) {
                const issue = issues[i];
                commentBody += `**${i + 1}. ${issue.rule || 'Security Issue'}**\n`;
                commentBody += `- **Severity:** ${issue.severity || 'Unknown'}\n`;
                commentBody += `- **Location:** `${issue.location?.path || 'Unknown'}:${issue.location?.start_line || 'Unknown'}`\n`;
                if (issue.url) {
                  commentBody += `- **[View Details](${issue.url})**\n`;
                }
                commentBody += `\n`;
              }
            }
            
            commentBody += `### ü§ñ Copilot Autofix Available\n`;
            commentBody += `GitHub Copilot Autofix has been enabled for this repository. Check the **Security tab** for automated fix suggestions.\n\n`;
            commentBody += `### Next Steps:\n`;
            commentBody += `1. ‚úÖ **Review Copilot Autofix suggestions** in the Security tab\n`;
            commentBody += `2. üîß **Apply fixes** or implement manual fixes\n`;
            commentBody += `3. üîÑ **Push your changes** to trigger a new security scan\n`;
            commentBody += `4. üö´ **Or acknowledge issues** by commenting: \`/acknowledge-security-issues\`\n\n`;
            commentBody += `‚ö†Ô∏è **The workflow is blocked until these issues are resolved or acknowledged.**`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
            
      - name: Check for Issue Acknowledgment
        id: check-acknowledgment
        if: steps.check-security-issues.outputs.has_issues == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          
          # Check for acknowledgment comment
          ACKNOWLEDGED=$(gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
            --jq '.[] | select(.body | contains("/acknowledge-security-issues")) | .user.login' | head -1)
          
          # Check if PR has 'security-issues-acknowledged' label
          LABEL_EXISTS=$(gh api "repos/$REPO/issues/$PR_NUMBER/labels" \
            --jq '.[] | select(.name == "security-issues-acknowledged") | .name' | head -1)
          
          if [[ -n "$ACKNOWLEDGED" || -n "$LABEL_EXISTS" ]]; then
            echo "acknowledged=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Security issues acknowledged by: $ACKNOWLEDGED"
            
            # Add label if not present
            if [[ -z "$LABEL_EXISTS" ]]; then
              gh api "repos/$REPO/issues/$PR_NUMBER/labels" \
                -f labels[]="security-issues-acknowledged" || true
            fi
          else
            echo "acknowledged=false" >> $GITHUB_OUTPUT
            echo "‚ùå Security issues not yet acknowledged"
          fi
          
      - name: Block if Security Issues Not Resolved or Acknowledged
        if: steps.check-security-issues.outputs.has_issues == 'true' && steps.check-acknowledgment.outputs.acknowledged == 'false'
        run: |
          echo "üö´ WORKFLOW BLOCKED: Security issues detected and not acknowledged"
          echo "Please either:"
          echo "  1. Fix the security issues using Copilot Autofix suggestions"
          echo "  2. Push your changes to trigger a new security scan"
          echo "  3. Comment '/acknowledge-security-issues' to proceed with known issues"
          exit 1
          
      - name: Set CodeQL status
        id: set-codeql-status
        if: always()
        run: |
          if [[ "${{ steps.codeql-analysis.outcome }}" == "success" ]]; then
            if [[ "${{ steps.check-security-issues.outputs.has_issues }}" == "true" && "${{ steps.check-acknowledgment.outputs.acknowledged }}" == "false" ]]; then
              echo "status=blocked" >> $GITHUB_OUTPUT
            else
              echo "status=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
          
      - name: Set Copilot status
        id: set-copilot-status
        if: always()
        run: |
          # Copilot Autofix is built-in, so status is based on whether it's enabled and working
          if [[ "${{ steps.check-security-issues.outputs.has_issues }}" == "true" ]]; then
            echo "status=autofix_available" >> $GITHUB_OUTPUT
          else
            echo "status=not_needed" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 3. Code Owner Approval - Always required for all PRs
# ----------------------------------------------------------------------
  codeowner-approval:
    name: codeowner-approval
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' && 
      (needs.code-security.outputs.has_security_issues == 'false' || 
       needs.code-security.outputs.issues_acknowledged == 'true')
    needs: [validate-pr, code-security]
    timeout-minutes: 30
    outputs:
      status: ${{ steps.set-approval-status.outputs.status }}
    steps:
      - name: Wait for a code-owner approval
        id: wait-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          echo "üïô polling every 5 s for code-owner approval (max 30 min)‚Ä¶"
          
          for i in $(seq 1 360); do
            approved=$(gh api "repos/$REPO/pulls/$PR/reviews" \
              --jq '[group_by(.user.login)[].[-1] | select(.state=="APPROVED")] | length')
            if [[ "$approved" -gt 0 ]]; then
              echo "üéâ code-owner has approved ‚Äì check succeeds"
              echo "approved=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "‚åõ timed-out waiting for code-owner approval"
          echo "approved=false" >> $GITHUB_OUTPUT
          exit 1
          
      - name: Set approval status
        id: set-approval-status
        if: always()
        run: |
          if [[ "${{ steps.wait-approval.outputs.approved }}" == "true" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

# ----------------------------------------------------------------------
# 4. UNIFIED MERGE GATE - Handles both TST and PRD with appropriate requirements
# ----------------------------------------------------------------------
  merge-gate:
    name: merge-gate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [validate-pr, code-security, codeowner-approval]
    timeout-minutes: 1440  # 24 hours max for platform approval
    outputs:
      status: ${{ steps.final-status.outputs.status }}
    steps:
      - name: Determine Environment and Requirements
        id: check-environment
        run: |
          if [[ "${{ github.base_ref }}" == "tst" ]]; then
            echo "environment=test" >> $GITHUB_OUTPUT
            echo "requires_platform_approval=false" >> $GITHUB_OUTPUT
            echo "üü¢ TEST environment deployment - Platform approval NOT required"
          elif [[ "${{ github.base_ref }}" == "prd" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "requires_platform_approval=true" >> $GITHUB_OUTPUT
            echo "üî¥ PRODUCTION environment deployment - Platform approval REQUIRED"
          fi

      - name: Validate Basic Requirements Passed
        run: |
          echo "üîç Validating all basic requirements..."
          
          VALIDATE_STATUS="${{ needs.validate-pr.outputs.status }}"
          SECURITY_STATUS="${{ needs.code-security.outputs.codeql_status }}"
          CODEOWNER_STATUS="${{ needs.codeowner-approval.outputs.status }}"
          
          echo "üìä Basic Requirements Status:"
          echo "  ‚úÖ validate-pr: $VALIDATE_STATUS"
          echo "  ‚úÖ code-security: $SECURITY_STATUS"
          echo "  ‚úÖ codeowner-approval: $CODEOWNER_STATUS"
          
          FAILED_CHECKS=""
          
          if [[ "$VALIDATE_STATUS" != "success" ]]; then
            FAILED_CHECKS="${FAILED_CHECKS}validate-pr "
          fi
          
          if [[ "$SECURITY_STATUS" != "success" ]]; then
            FAILED_CHECKS="${FAILED_CHECKS}code-security "
          fi
          
          if [[ "$CODEOWNER_STATUS" != "success" ]]; then
            FAILED_CHECKS="${FAILED_CHECKS}codeowner-approval "
          fi
          
          if [[ -n "$FAILED_CHECKS" ]]; then
            echo "‚ùå Basic requirements failed: $FAILED_CHECKS"
            exit 1
          fi
          
          echo "‚úÖ All basic requirements satisfied"

      - name: Allow TEST Environment Merge
        if: steps.check-environment.outputs.requires_platform_approval == 'false'
        run: |
          echo "üü¢ TEST ENVIRONMENT - Merge Approved"
          echo "‚úÖ All required checks passed for TEST deployment"
          echo "üöÄ PR is ready to merge - no additional approvals needed"
          echo ""
          echo "üìã Satisfied Requirements:"
          echo "  ‚úÖ Branch flow validation"
          echo "  ‚úÖ Security analysis"  
          echo "  ‚úÖ Code owner approval"
          echo ""
          echo "üéâ TEST deployment can proceed!"

      - name: Require Platform Approval for Production
        if: steps.check-environment.outputs.requires_platform_approval == 'true'
        id: platform-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üî¥ PRODUCTION ENVIRONMENT - Platform Approval Required"
          echo "üö´ This merge gate will BLOCK until platform approval is granted"
          
          REPO="${{ github.repository }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Get platform approver usernames
          PLATFORM_APPROVER_1="${{ vars.PLATFORM_APPROVER_1 }}"
          PLATFORM_APPROVER_2="${{ vars.PLATFORM_APPROVER_2 }}"
          
          if [[ -z "$PLATFORM_APPROVER_1" || -z "$PLATFORM_APPROVER_2" ]]; then
            echo "‚ùå Platform approver usernames not configured"
            exit 1
          fi
          
          # Add blocking comment to PR immediately
          gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
            -f body="## üî¥ PRODUCTION Deployment - Platform Approval Required

          **Status:** üö´ **MERGE BLOCKED** - Waiting for platform team approval  
          **Environment:** üî¥ **PRODUCTION**  
          **Requirements:** All basic checks ‚úÖ passed, platform approval ‚è≥ pending  

          ### üö´ Merge Status
          This PR **CANNOT be merged** until platform approval is granted.  
          The workflow will remain blocked until approval is received.

          ### üë• Authorized Approvers  
          - @$PLATFORM_APPROVER_1  
          - @$PLATFORM_APPROVER_2  

          ### ‚è±Ô∏è Process  
          - Platform approval issue will be created automatically  
          - Maximum wait time: 24 hours  
          - Auto-rejection if no response within timeout  

          ---
          *Platform approval is mandatory for all production deployments.*"
          
          # Check if approval issue already exists
          EXISTING_ISSUE=$(gh api "repos/$REPO/issues" \
            --jq '.[] | select(.title | contains("PRODUCTION Deployment Approval Required - PR #'$PR_NUMBER'") and .state == "open") | .number' | head -1)
          
          if [[ -n "$EXISTING_ISSUE" ]]; then
            echo "üìã Using existing approval issue #$EXISTING_ISSUE"
            ISSUE_NUMBER="$EXISTING_ISSUE"
          else
            # Create platform approval issue
            ISSUE_TITLE="üî¥ PRODUCTION Deployment Approval Required - PR #$PR_NUMBER"
            CURRENT_TIME=$(date -u "+%A, %B %d, %Y at %H:%M UTC")
            
            ISSUE_BODY=$(cat <<EOF
          # üî¥ Production Deployment Approval Request

          ## üìã Deployment Summary
          | Field | Value |
          |-------|-------|
          | **Environment** | üî¥ **PRODUCTION** |
          | **Pull Request** | [#$PR_NUMBER](${{ github.event.pull_request.html_url }}) |
          | **Requested By** | @${{ github.actor }} |
          | **Request Time** | $CURRENT_TIME |
          | **Branch Flow** | \`${{ github.head_ref }}\` ‚Üí \`${{ github.base_ref }}\` |

          ## ‚úÖ Pre-Deployment Validation Status
          All mandatory checks completed and passed:
          - ‚úÖ **Branch Flow**: Verified  
          - ‚úÖ **Security Analysis**: Completed  
          - ‚úÖ **Code Owner Approval**: Approved  

          ## üéØ Required Action
          **To Approve:** Comment \`/approve\`, \`approved\`, or \`lgtm\`  
          **To Reject:** Comment \`/reject\`, \`rejected\`, or \`deny\`  

          **Authorized Approvers:** @$PLATFORM_APPROVER_1 OR @$PLATFORM_APPROVER_2  
          **Timeout:** 24 hours maximum wait time  

          ## üö® Important  
          - PR is **BLOCKED** until platform approval  
          - Workflow will wait up to 24 hours for response  
          - Auto-rejection after timeout  

          ---
          *Platform approval required for production deployment.*
          EOF
          )
            
            ISSUE_RESPONSE=$(gh api "repos/$REPO/issues" \
              -f title="$ISSUE_TITLE" \
              -f body="$ISSUE_BODY" \
              -f assignees[]="$PLATFORM_APPROVER_1" \
              -f assignees[]="$PLATFORM_APPROVER_2")
            
            ISSUE_NUMBER=$(echo "$ISSUE_RESPONSE" | jq -r '.number')
            echo "üìã Created platform approval issue #$ISSUE_NUMBER"
          fi
          
          # Now BLOCK and wait for platform approval
          echo "‚è≥ BLOCKING: Waiting for platform approval on issue #$ISSUE_NUMBER..."
          
          TIMEOUT_SECONDS=86400  # 24 hours
          POLL_INTERVAL=30
          MAX_ITERATIONS=$((TIMEOUT_SECONDS / POLL_INTERVAL))
          
          for ((i=1; i<=MAX_ITERATIONS; i++)); do
            echo "üîç Platform approval check $i/$MAX_ITERATIONS - $(date -u)"
            
            COMMENTS=$(gh api "repos/$REPO/issues/$ISSUE_NUMBER/comments" --jq '.')
            
            while IFS= read -r comment; do
              if [[ -z "$comment" || "$comment" == "null" ]]; then
                continue
              fi
              
              COMMENT_AUTHOR=$(echo "$comment" | jq -r '.user.login')
              COMMENT_BODY=$(echo "$comment" | jq -r '.body' | tr '[:upper:]' '[:lower:]')
              
              if [[ "$COMMENT_AUTHOR" == "$PLATFORM_APPROVER_1" || "$COMMENT_AUTHOR" == "$PLATFORM_APPROVER_2" ]]; then
                if [[ "$COMMENT_BODY" =~ (approve|approved|lgtm|/approve) ]]; then
                  echo "üéâ ‚úÖ PRODUCTION APPROVED by @$COMMENT_AUTHOR!"
                  echo "approved=true" >> $GITHUB_OUTPUT
                  echo "approver=$COMMENT_AUTHOR" >> $GITHUB_OUTPUT
                  
                  # Update PR with approval
                  gh api "repos/$REPO/issues/$PR_NUMBER/comments" \
                    -f body="## ‚úÖ Production Deployment Approved

                  **‚úÖ MERGE NOW ENABLED**  
                  **Approved By:** @$COMMENT_AUTHOR (Platform Team)  
                  **Time:** $(date -u)  
                  **Status:** PR is ready to merge üöÄ"
                  
                  exit 0
                fi
                
                if [[ "$COMMENT_BODY" =~ (reject|rejected|deny|/reject) ]]; then
                  echo "‚ùå PRODUCTION REJECTED by @$COMMENT_AUTHOR"
                  echo "approved=false" >> $GITHUB_OUTPUT
                  echo "rejector=$COMMENT_AUTHOR" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi
            done <<< "$(echo "$COMMENTS" | jq -c '.[]')"
            
            sleep $POLL_INTERVAL
          done
          
          # Timeout
          echo "‚è∞ TIMEOUT: No platform approval within 24 hours"
          echo "approved=false" >> $GITHUB_OUTPUT
          echo "timeout=true" >> $GITHUB_OUTPUT
          exit 1

      - name: Set Final Status
        id: final-status
        if: always()
        run: |
          if [[ "${{ steps.check-environment.outputs.requires_platform_approval }}" == "false" ]]; then
            # TEST environment - no platform approval needed
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ TEST environment merge approved"
          elif [[ "${{ steps.platform-approval.outputs.approved }}" == "true" ]]; then
            # PRODUCTION environment - platform approved
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ PRODUCTION environment merge approved"
          else
            # PRODUCTION environment - platform approval failed/timeout
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå PRODUCTION environment merge blocked"
            exit 1
          fi

# ----------------------------------------------------------------------
# 5. Deployment Pipeline - Runs after successful merge
# ----------------------------------------------------------------------
  trigger-harness-pipeline:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/tst' || github.ref == 'refs/heads/prd')
    outputs:
      harness_status: ${{ steps.set-harness-status.outputs.status }}
    steps:
       - name: Checkout code
         uses: actions/checkout@v4
         
       - name: Check Previous PR Workflow Status
         id: check-pr-status
         env:
           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
         run: |
           echo "üîç Checking status of previous PR workflow..."
           
           # Get the merge commit PR number
           COMMIT_MSG=$(git log -1 --pretty=%B | head -1)
           if [[ "$COMMIT_MSG" =~ Merge\ pull\ request\ #([0-9]+) ]]; then
             PR_NUMBER="${BASH_REMATCH[1]}"
             echo "üîó Found PR: #$PR_NUMBER"
           else
             echo "‚ùå Could not extract PR number from merge commit"
             exit 1
           fi
           
           REPO="${{ github.repository }}"
           PR_INFO=$(gh api "repos/$REPO/pulls/$PR_NUMBER")
           HEAD_SHA=$(echo "$PR_INFO" | jq -r '.head.sha')
           
           # Find matching workflow run
           MATCHING_RUNS=$(gh api "repos/$REPO/actions/runs" --paginate \
             --jq '.workflow_runs[] | select(.head_sha == "'$HEAD_SHA'" and .name == "Branch Protection and Pipeline Trigger" and .event == "pull_request")')
           
           LATEST_RUN=$(echo "$MATCHING_RUNS" | jq -s 'sort_by(.run_number) | reverse | .[0]')
           WORKFLOW_CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
           
           if [[ "$WORKFLOW_CONCLUSION" != "success" ]]; then
             echo "‚ùå PR workflow was not successful: $WORKFLOW_CONCLUSION"
             exit 1
           fi
           
           echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

       - name: Determine migration configuration
         id: migration-config
         run: |
           BRANCH_NAME="${{ github.ref_name }}"
         
           if [[ "$BRANCH_NAME" == "tst" ]]; then
             echo "migration_type=dev-to-tst" >> $GITHUB_OUTPUT
             echo "environment=tst" >> $GITHUB_OUTPUT
           elif [[ "$BRANCH_NAME" == "prd" ]]; then
             echo "migration_type=tst-to-prd" >> $GITHUB_OUTPUT
             echo "environment=prd" >> $GITHUB_OUTPUT
           fi

       - name: Trigger Harness Pipeline
         run: |
           echo "üöÄ Triggering Harness pipeline for ${{ steps.migration-config.outputs.migration_type }}"
           
           RESPONSE=$(curl -s -w "%{http_code}" -X POST "${{ secrets.HARNESS_WEBHOOK_URL }}" \
             -H "Content-Type: application/json" \
             -d "{
               \"repository\": \"${{ github.server_url }}/${{ github.repository }}\",
               \"triggered_by\": \"${{ github.actor }}\",
               \"migration_type\": \"${{ steps.migration-config.outputs.migration_type }}\",
               \"environment\": \"${{ steps.migration-config.outputs.environment }}\",
               \"PR_URL\": \"https://github.com/${{ github.repository }}/pull/${{ steps.check-pr-status.outputs.pr_number }}\",
               \"EDB_ID\": \"${{ vars.EDB_ID }}\",
               \"commit_sha\": \"${{ github.sha }}\",
               \"branch_name\": \"${{ github.ref_name }}\"
             }")
          
           HTTP_CODE="${RESPONSE: -3}"
         
           if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
             echo "‚úÖ Successfully triggered Harness pipeline"
           else
             echo "‚ùå Failed to trigger Harness pipeline"
             exit 1
           fi

       - name: Set Harness status
         id: set-harness-status
         if: always()
         run: |
           echo "status=success" >> $GITHUB_OUTPUT
